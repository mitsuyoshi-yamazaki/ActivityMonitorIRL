# デザインパターン解説

## MVVMパターンの概要

MVVM（Model-View-ViewModel）パターンは、UIアプリケーションにおいて関心の分離を実現するためのアーキテクチャパターンです。Microsoftが2005年にWPF向けに提案したパターンで、宣言的なデータバインディングを持つUIフレームワークに適しています。

### 基本構成要素

#### Model（モデル）
- **役割**: データ構造とビジネスロジックを表現
- **責務**: データの整合性維持、ビジネスルールの実装
- **特徴**: UIに依存しない、再利用可能

#### View（ビュー）
- **役割**: ユーザーインターフェースの表示とユーザー操作の受信
- **責務**: レイアウト、イベントハンドリング、ViewModelへの操作委譲
- **特徴**: 宣言的、ViewModelの状態を観察して自動更新

#### ViewModel（ビューモデル）
- **役割**: ViewとModelの仲介、プレゼンテーション層のロジック
- **責務**: View向けのデータ変換、ユーザー操作の処理、状態管理
- **特徴**: Viewから独立してテスト可能、複数Viewで再利用可能

## SwiftUIにおけるMVVM実装

SwiftUIの`@ObservableObject`と`@Published`プロパティラッパーにより、MVVMパターンの宣言的なデータバインディングが実現されます。

### データフロー

1. **View → ViewModel**: ユーザー操作により ViewModelのメソッド呼び出し
2. **ViewModel → Model**: ビジネスロジック実行、データ変更
3. **Model → ViewModel**: 変更結果を`@Published`プロパティに反映
4. **ViewModel → View**: `@Published`の変更により自動的にView更新

### 各登場人物の具体的役割

#### ObservableObject（ViewModel）
```swift
class DailyActivityViewModel: ObservableObject {
    @Published var records: [Int: ActivityRecord] = [:]
    @Published var selectedDate: Date = Date()
}
```
- `ObservableObject`プロトコルに準拠
- `@Published`で状態変更を通知
- Viewのライフサイクルから独立したビジネスロジック

#### @StateObject / @ObservedObject（View側）
```swift
struct DailyActivityView: View {
    @StateObject private var viewModel = DailyActivityViewModel()
}
```
- `@StateObject`: ViewModelのライフサイクル管理
- `@ObservedObject`: 外部から注入されたViewModelの観察
- `@Published`プロパティの変更を自動検知してView再描画

#### Repository Pattern（データアクセス層）
```swift
class ActivityRepository {
    func save(_ record: ActivityRecord) async throws { }
    func fetch(for date: Date) async throws -> [ActivityRecord] { }
}
```
- ViewModelとデータ永続化層の分離
- テスタビリティとモック化の向上
- 複数のデータソース（SQLite、API等）への対応

## 関連パターンと参考資料

### Observer パターン
MVVMの基盤となるパターン。SwiftUIでは`@Published`と`@ObservedObject`がObserverパターンを実装。

### Repository パターン
データアクセスロジックをカプセル化し、ビジネスロジックから分離するパターン。

### 参考リンク

- [Apple Developer - Managing Model Data in Your App](https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app)
- [SwiftUI ObservableObject](https://developer.apple.com/documentation/combine/observableobject)
- [MVVM Pattern - Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/architecture/maui/mvvm)
- [Repository Pattern - Martin Fowler](https://martinfowler.com/eaaCatalog/repository.html)
- [Observer Pattern - Gang of Four](https://en.wikipedia.org/wiki/Observer_pattern)

## 本アプリケーションでの実装指針

1. **単一責任**: 各ViewModelは単一画面の状態管理に特化
2. **依存性注入**: RepositoryはViewModelに注入、テスト時にモック化
3. **非同期処理**: async/awaitを使用してメインスレッドをブロックしない
4. **エラーハンドリング**: ViewModelでエラーを捕捉し、適切なUI状態に変換
5. **メモリ管理**: 強参照循環を避けるため`@StateObject`と`@ObservedObject`を適切に使い分け

## 責務分離とロジックの配置指針

### 各層の責務と境界

#### Repository層
- **純粋なデータアクセス機能**: データの取得、保存、削除、検索
- **ドメイン非依存の汎用処理**: データの状態を調べる、集計する、範囲を特定する
- **技術的な関心事**: SQLクエリ、ファイルI/O、ネットワーク通信
- **再利用可能な機能**: 複数のユースケースで共通して使える機能

#### ViewModel層  
- **ビジネスロジック**: ドメインのルールや制約を適用する処理
- **ドメイン知識の実装**: 「起床」「就寝」「活動」といった概念の判定・操作
- **UI状態の管理**: 画面表示に必要な状態の保持と更新
- **データ変換**: Repository からの生データをUI表示用に加工

#### View層
- **プレゼンテーション**: レイアウト、アニメーション、色彩
- **ユーザーインタラクション**: タップ、スワイプ、入力の受付
- **表示判定**: ViewModelの状態に基づくUI要素の表示・非表示
- **操作の委譲**: ユーザーアクションをViewModelメソッドに委譲

### ロジック分解の判断基準

新しい機能を実装する際は、以下の基準でロジックを分解し、適切な層に配置します：

#### 1. ドメイン知識の有無
- **ドメイン知識を含む**: ViewModel層に配置
  - 例：「連続して未記録なら起床時刻」「睡眠記録の作成」
- **ドメイン知識を含まない**: Repository層に配置
  - 例：「指定時刻を含む未記録範囲の特定」「日付別データ取得」

#### 2. 再利用性の観点
- **汎用的で再利用可能**: Repository層に配置
  - 他の機能でも使える可能性が高い処理
- **特定用途に特化**: ViewModel層に配置
  - 特定の画面や機能でのみ必要な処理

#### 3. テスタビリティ
- **独立してテスト可能にしたい**: 下位層（Repository）に配置
- **UIと連携したテストが必要**: 上位層（ViewModel）に配置

#### 4. 変更の影響範囲
- **データ構造や永続化の変更**: Repository層
- **ビジネスルールの変更**: ViewModel層  
- **UI仕様の変更**: View層

### 設計例：複雑な機能の分解

複雑な機能は以下のように分解します：

1. **要件を分析**: どの部分がドメイン知識で、どの部分が技術的処理か
2. **境界を特定**: データアクセス部分とビジネスロジック部分を分離
3. **汎用性を検討**: 他の機能で再利用できる部分をRepository層へ
4. **責務を明確化**: 各メソッドが単一の責務を持つよう設計

この分解により、将来の機能追加や変更に対して柔軟で保守性の高いアーキテクチャを実現できます。